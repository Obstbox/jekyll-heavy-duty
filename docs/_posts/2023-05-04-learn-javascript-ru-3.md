---
layout: post
title: learn.javascript.ru - 3
---

### шпаргалка по {{ page.title }}

`let obj1 = new Object();`  
`let obj2 = {};`  

`user.foo()` тоже самое что `user['foo']()`  

имя свойства объекта может состоять из _нескольких слов_, но тогда имя нужно обернуть в кавычки  
последнее свойство объекта может заканчиваться _висячей_ запятой  
содержимое объекта, объявленного через _const_ может быть измененно  
доступ к свойствам объекта: через `.` или `[]`  
- `obj.["value long name"]` - (_только так_ можно обратиться к именам, содержащим пробел)  
- `obj.[key]    // key = "age"` - подстановка имени свойства  
- _литеральная_ нотация (\*)  
- составные конструкции (\*\*)  

```js
let fruit = prompt(...)         // fruit = apple
let bag = {
    [fruit]: 5,                   // (*)
    [fruit + 'Computers']: 3,     // appleComputers (**)
};
```

часто имена свойств и переменных совпадают. тогда:  
```js
function makeUser(name, age) {
    return {
        name: name,
        age: age,

    // == тоже самое ==
    return { 
        name,
        age,
    // ================
    };
}
```

---  

для _имен свойств_ нет ограничений как для _обычных переменных_ (кроме `__proto__`). `var.let`, `var.for`, `var.return`
и `var.7` допустимы  

ключи свойств могут быть строками (помним про `+val`) или символами  
в javascript можно получить доступ к __любому__ свойству. если оно не существует, ошибки не будет, а будет `undefined`  
можно проверить оператором `in`: `alert( "age" in user);  // true или false`  
особенность `in` в том, что свойство может на самом деле _существовать_, но его значение равно `undefined` (что на
самом деле редкость)  

перебор свойств: `for - in`  
`for (let key in user) { ... } // часто (let prop ...)`  

клонирование:  
- `let clone = {}; for (let key in user) { clone[key] = user[key];}`  
- `Object.assign(dest, [src1, src2, ...])   // изменяет dest`  
- `let clone = Object.assign({}, src);      // возвращает в clone`  
- `clone = {...src}                         // через оператор расширения`

### сборщик мусора
сборка выполняется автоматически, нельзя ускорить или предотвратить  
объекты сохраняются в памяти, пока достижимы (их корни). важны входящие ссылки  
разные движки имеют разные но схожие подходы (сборка по поколениям, инкрементальная и сборка в свободное время; и проч.)  

### контекст и .this 

> В JavaScript `this` является «свободным», его значение вычисляется в момент вызова метода и не зависит от того, где 
этот метод был объявлен, а скорее от того, какой объект вызывает метод  
`this` в js ведёт себя иначе, чем в большинстве других ЯП. `this` можно вызывать из _любой_ функции, а не только у методов  
> Правило простое: если вызывается `obj.f()`, то во время вызова `f`, `this` – это `obj`  

у _стрелочных функций_ нет своего `this`; `this` берётся из внешней функции  

```js
// взрыв мозга 1
function makeUser() {
  return {
    name: "John",
    ref: this // this принимает значение this ф-ии makeUser()
  };
}

let user = makeUser();
alert( user.ref.name ); // undefined (ошибка)

// взрыв мозга 2
function makeUser() {
  return {
    name: "John",
    ref() {
      return this;
    }
  };
}

let user = makeUser();
// а так можно. это работает "потому что user.ref() - это метод"
alert( user.ref().name ); // John
```
для того, чтобы методы объекта можно было вызывать по цепочке, нужно из каждого метода возвращать сам объект `return this`  

### функции-конструкторы
нужны для создания _однотипных объектов_  
имя начинается с _заглавной_ буквы  
выполняется только с оператором `new`  
технически, любая функция (кроме стрелочной) может быть конструктором  
```js
let user = new User()
let user = new User     // разрешено без скобок, но не принято

let user = new function() {     // анонимно
    this.name = 'John'
    ...
```
обычно конструкторы не имеют оператора `return`. их задача - всё необходимое записать в `this`, это и есть результать. но если `return` есть:  
- `return` с объектом вернёт _объект_ а не `this`  
- `return` с примитивом игнорируется  

