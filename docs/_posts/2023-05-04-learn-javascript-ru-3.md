---
layout: post
title: learn.javascript.ru - 3
---

### шпаргалка по {{ page.title }}

`let obj1 = new Object();`  
`let obj2 = {};`  

имя свойства объекта может состоять из _нескольких слов_, но тогда имя нужно обернуть в кавычки  
последнее свойство объекта может заканчиваться _висячей_ запятой  
содержимое объекта, объявленного через _const_ может быть измененно  
доступ к свойствам объекта: через `.` или `[]`  
- `obj.["value long name"]` - (_только так_ можно обратиться к именам, содержащим пробел)  
- `obj.[key]    // key = "age"` - подстановка имени свойства  
- _литеральная_ нотация (\*)  
- составные конструкции (\*\*)  

```js
let fruit = prompt(...)         // fruit = apple
let bag = {
    [fruit]: 5,                   // (*)
    [fruit + 'Computers']: 3,     // appleComputers (**)
};
```

часто имена свойств и переменных совпадают. тогда:  
```js
function makeUser(name, age) {
    return {
        name: name,
        age: age,

    // == тоже самое ==
    return { 
        name,
        age,
    // ================
    };
}
```

---  

для _имен свойств_ нет ограничений как для _обычных переменных_ (кроме `__proto__`). `var.let`, `var.for`, `var.return`
и `var.7` допустимы  

ключи свойств могут быть строками (помним про `+val`) или символами  
в javascript можно получить доступ к __любому__ свойству. если оно не существует, ошибки не будет, а будет `undefined`  
можно проверить оператором `in`: `alert( "age" in user);  // true или false`  
особенность `in` в том, что свойство может на самом деле _существовать_, но его значение равно `undefined` (что на
самом деле редкость)  

перебор свойств: `for - in`  
`for (let key in user) { ... } // часто (let prop ...)`  

клонирование:  
- `let clone = {}; for (let key in user) { clone[key] = user[key];}`  
- `Object.assign(dest, [src1, src2, ...])   // изменяет dest`  
- `let clone = Object.assign({}, src);      // возвращает в clone`  
- `clone = {...src}                         // через оператор расширения`
